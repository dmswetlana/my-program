//В первый день спортсмен пробежал 10 км. В каждый седующий
//он пробегал на 10% больше, чем в предыдущий.
//1. Сколько км он пробежит в 10-й день?
//2.В какой днгь он впервые пробежит больше 20 км?
//3. За сколько дней его суммарный пробег превысит 100 км?

#include<iostream>
#include<cstdio>
#include<clocale>

using std::cout;
using std::cin;

#define FINAL_DAY 10
#define START_DIST 10
#define FINAL_DIST 20
#define TOTAL_DIST 100
#define PERCENT 10
#define FACTOR (100+PERCENT)/100.0 //сколько он пробежит в следующий день

#define MYDEBUG

#ifndef MYDEBUG
#define DUMP(ival,fval)
#else
#define DUMP(ival,fval) printf(#ival"=%d\t"#fval"=%f\n",ival,fval)
#endif

int main()
{
	double x, //ежедневный пробег
		  s; //суммарный пробег
	int   n; //счётчик дней

	setlocale(LC_CTYPE, ".866");

	for (n = 1, x = START_DIST; n < FINAL_DAY; ++n, x *= FACTOR)
		DUMP(n, x); //само тело цикла пустое, так как всё описали в for
	                //и вставили в него отладочный макрос (печать)
	wprintf(L"В %d-й день спортсмен пробежал %3.f км\n\n", n, x);

	for (n = 1, x = START_DIST; x < FINAL_DIST; ++n, x *= FACTOR)
		DUMP(n, x);

	wprintf(L"B %d-й день спортсмен пробежал %.3f км\n\n", n, x);

	for (n = 1, s = x = START_DIST; s < TOTAL_DIST; ++n, s +=x *= FACTOR)
	DUMP(n, s);
	wprintf(L"За %d дней спортсмен пробежал %.3f км \n\n", n, s);

	system("pause");
	return 0;
}


/* разберём запись первого цикла
for (n = 1, x = START_DIST; x < FINAL_DAY; ++n, x *= FACTOR)
n = 1, x = START_DIST - для начальной подготовки цикла
нам нужно задать счётчик дней = 1 и стартовый пробег x = START_DIST.
Два выражения соединили запятой, которые превращаются в одно выражение.
Они вычисляются слева направо.
x < FINAL_DAY - это условие, сколько бегать.
++n, x *= FACTOR - подготовка к следующей операции. В чём она состоит?
инкремент счётчику и вычисляем (х) за следующий день.
заменяем (х) на новое значение. (х) умножаем на процентный рост.
В результате в теле цикла нам вообще нечего делать (тело цикла пустое).
А в само тело цикла вставили отладочный макрос.
Он распечатывает имя этой переменной  и её значение на каждом шаге цикла.

Второй цикл устроен точно также, только окончание другое.
for (n = 1, x = START_DIST; x < FINAL_DIST; ++n, x *= FACTOR)
когда x < FINAL_DIST

А в третьем цикле
for (n = 1, s = x = START_DIST; s < TOTAL_DIST; ++n, s +=x *= FACTOR)
n = 1, - это первый день
s = x = START_DIST - потому что пробег в первый день и есть
суммарная дистанция за этот день.
++n, s +=x *= FACTOR - подготовка к следующей итерации.
++n, счётчик дней увеличивается
s +=x *= FACTOR и пересчитывается сначала (х) на следующий день 
и тут же пересчитанное значение накапливается в сумму.

Оператор (запятая) объединяет вместе два выражения, предлагая
компилятору считать, что это одно выражение новое, которое
вычисляется по таким правилам: вначале вычисляется левый операнд,
его значение не влияет на результат всего значения оператора (запятая).
Потом вычисляется правый операнд  и его значение будет значением
всего результата оператора (запятая). вычисление слева направо.

for (n = 1, s = x = START_DIST; s < TOTAL_DIST; ++n, s +=x *= FACTOR)
можно было бы записать и так:
for (n = 1, s=0,  x = START_DIST; s +=x, s < TOTAL_DIST; ++n, x *= FACTOR)

*/
